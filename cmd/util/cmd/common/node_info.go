package common

import (
	"strings"

	"github.com/rs/zerolog"

	"github.com/onflow/flow-go/cmd/bootstrap/cmd"
	"github.com/onflow/flow-go/model/bootstrap"
	"github.com/onflow/flow-go/model/flow"
)

// ReadPartnerNodeInfos returns a list of partner nodes after gathering weights
// and public key information from configuration files
func ReadPartnerNodeInfos(log zerolog.Logger, partnerWeightsPath, partnerNodeInfoDir string) []bootstrap.NodeInfo {
	partners := ReadPartnerNodes(log, partnerNodeInfoDir)
	log.Info().Msgf("read %d partner node configuration files", len(partners))

	var weights cmd.PartnerWeights
	err := ReadJSON(partnerWeightsPath, &weights)
	if err != nil {
		log.Fatal().Err(err).Msg("failed to read partner weights json")
	}
	log.Info().Msgf("read %d weights for partner nodes", len(weights))

	var nodes []bootstrap.NodeInfo
	for _, partner := range partners {
		// validate every single partner node
		nodeID := cmd.ValidateNodeID(partner.NodeID)
		networkPubKey := cmd.ValidateNetworkPubKey(partner.NetworkPubKey)
		stakingPubKey := cmd.ValidateStakingPubKey(partner.StakingPubKey)
		weight, valid := cmd.ValidateWeight(weights[partner.NodeID])
		if !valid {
			log.Error().Msgf("weights: %v", weights)
			log.Fatal().Msgf("partner node id %x has no weight", nodeID)
		}
		if weight != flow.DefaultInitialWeight {
			log.Warn().Msgf("partner node (id=%x) has non-default weight (%d != %d)", partner.NodeID, weight, flow.DefaultInitialWeight)
		}

		node := bootstrap.NewPublicNodeInfo(
			nodeID,
			partner.Role,
			partner.Address,
			weight,
			networkPubKey.PublicKey,
			stakingPubKey.PublicKey,
		)
		nodes = append(nodes, node)
	}

	return nodes
}

// ReadPartnerNodes reads the partner node information
func ReadPartnerNodes(log zerolog.Logger, partnerNodeInfoDir string) []bootstrap.NodeInfoPub {
	var partners []bootstrap.NodeInfoPub
	files, err := FilesInDir(partnerNodeInfoDir)
	if err != nil {
		log.Fatal().Err(err).Msg("could not read partner node infos")
	}
	for _, f := range files {
		// skip files that do not include node-infos
		if !strings.Contains(f, bootstrap.PathPartnerNodeInfoPrefix) {
			continue
		}

		// read file and append to partners
		var p bootstrap.NodeInfoPub
		err = ReadJSON(f, &p)
		if err != nil {
			log.Fatal().Err(err).Msg("failed to read node info")
		}
		partners = append(partners, p)
	}
	return partners
}

// ReadInternalNodeInfos returns a list of internal nodes after collecting weights
// from configuration files.
func ReadInternalNodeInfos(log zerolog.Logger, internalNodePrivInfoDir, internalWeightsConfig string) []bootstrap.NodeInfo {
	privInternals := ReadInternalNodes(log, internalNodePrivInfoDir)
	log.Info().Msgf("read %v internal private node-info files", len(privInternals))

	weights := internalWeightsByAddress(log, internalWeightsConfig)
	log.Info().Msgf("read %d weights for internal nodes", len(weights))

	var nodes []bootstrap.NodeInfo
	for _, internal := range privInternals {
		// check if address is valid format
		ValidateAddressFormat(log, internal.Address)

		// validate every single internal node
		nodeID := cmd.ValidateNodeID(internal.NodeID)
		weight, valid := cmd.ValidateWeight(weights[internal.Address])
		if !valid {
			log.Error().Msgf("weights: %v", weights)
			log.Fatal().Msgf("internal node %v has no weight. Did you forget to update the node address?", internal)
		}
		if weight != flow.DefaultInitialWeight {
			log.Warn().Msgf("internal node (id=%x) has non-default weight (%d != %d)", internal.NodeID, weight, flow.DefaultInitialWeight)
		}

		node := bootstrap.NewPrivateNodeInfo(
			nodeID,
			internal.Role,
			internal.Address,
			weight,
			internal.NetworkPrivKey,
			internal.StakingPrivKey,
		)

		nodes = append(nodes, node)
	}

	return nodes
}

// ReadInternalNodes reads our internal node private infos generated by
// `keygen` command and returns it
func ReadInternalNodes(log zerolog.Logger, internalNodePrivInfoDir string) []bootstrap.NodeInfoPriv {
	var internalPrivInfos []bootstrap.NodeInfoPriv

	// get files in internal priv node infos directory
	files, err := FilesInDir(internalNodePrivInfoDir)
	if err != nil {
		log.Fatal().Err(err).Msg("could not read partner node infos")
	}

	// for each of the files
	for _, f := range files {
		// skip files that do not include node-infos
		if !strings.Contains(f, bootstrap.PathPrivNodeInfoPrefix) {
			continue
		}

		// read file and append to partners
		var p bootstrap.NodeInfoPriv
		err = ReadJSON(f, &p)
		if err != nil {
			log.Fatal().Err(err).Msg("failed to read json")
		}
		internalPrivInfos = append(internalPrivInfos, p)
	}

	return internalPrivInfos
}

// internalWeightsByAddress returns a mapping of node address by weight for internal nodes
func internalWeightsByAddress(log zerolog.Logger, config string) map[string]uint64 {
	// read json
	var configs []bootstrap.NodeConfig
	err := ReadJSON(config, &configs)
	if err != nil {
		log.Fatal().Err(err).Msg("failed to read json")
	}
	log.Info().Interface("config", configs).Msgf("read internal node configurations")

	weights := make(map[string]uint64)
	for _, config := range configs {
		if _, ok := weights[config.Address]; !ok {
			weights[config.Address] = config.Weight
		} else {
			log.Error().Msgf("duplicate internal node address %s", config.Address)
		}
	}

	return weights
}
