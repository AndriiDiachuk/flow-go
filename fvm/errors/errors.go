package errors

import (
	stdErrors "errors"
	"fmt"

	"github.com/onflow/cadence/runtime"
	"github.com/onflow/cadence/runtime/errors"
)

type Unwrappable interface {
	error
	Unwrap() error
}

type UnwrappableErrors interface {
	error
	Unwrap() []error
}

type CodedError interface {
	Code() ErrorCode

	Unwrappable
	error
}

// CodedFailure is a subtype of CodedError specifically for failures
// This is used to make type checking with `errors.As` and `errors.Is` easier and more accurate
type CodedFailure interface {
	Code() FailureCode

	Unwrappable
	error
}

// WrappedParentError is a wrapper for errors.ParentError to make it conform to the unwrappable
// interface used by the std errors lib. Once these error types are updated, this can be removed.
// See https://github.com/onflow/cadence/issues/3035
type WrappedParentError struct {
	errors.ParentError
}

func (err WrappedParentError) Unwrap() []error {
	return err.ParentError.ChildErrors()
}

// Is is a utility function to call std error lib `Is` function for instance equality checks.
func Is(err error, target error) bool {
	return stdErrors.Is(err, target)
}

// As is a utility function to call std error lib `As` function.
// As finds the first error in err's chain that matches target,
// and if so, sets target to that error value and returns true. Otherwise, it returns false.
// The chain consists of err itself followed by the sequence of errors obtained by repeatedly calling Unwrap.
func As(err error, target interface{}) bool {
	return stdErrors.As(err, target)
}

// findRootCodedError recursively unwraps the error to search for the root (deepest) coded error:
//  1. If err is nil, this returns (nil, false),
//  2. If err has no error code, this returns (nil, true),
//  3. If err has an error code, this returns
//     (<the deepest, aka root cause, coded error>, false)
//
// Note: This assumes the caller has already checked if the error contains a CodedFailure.
func findRootCodedError(err error) (CodedError, bool) {
	if err == nil {
		return nil, false
	}

	// If there are no coded errors, return immediately
	var coded CodedError
	if !As(err, &coded) {
		return nil, true
	}

	// find the deepest coded error
	for {
		var nextCoded CodedError
		if !As(coded.Unwrap(), &nextCoded) {
			return coded, false
		}

		coded = nextCoded
	}
}

// IsFailure returns true if the error is un-coded, or if the error contains
// a failure code.
func IsFailure(err error) bool {
	return AsFailure(err) != nil
}

func AsFailure(err error) CodedFailure {
	if err == nil {
		return nil
	}

	var failure CodedFailure
	if As(err, &failure) {
		return failure
	}

	var coded CodedError
	if !As(err, &coded) {
		return NewUnknownFailure(err)
	}

	return nil
}

// SplitErrorTypes splits the error into fatal (failures) and non-fatal errors
func SplitErrorTypes(inp error) (err CodedError, failure CodedFailure) {
	if inp == nil {
		return nil, nil
	}

	if failure = AsFailure(inp); failure != nil {
		return nil, WrapCodedFailure(
			failure.Code(),
			inp,
			"failure caused by")
	}

	coded, isUnknown := findRootCodedError(inp)
	if isUnknown {
		return nil, NewUnknownFailure(inp)
	}

	return WrapCodedError(
		coded.Code(),
		inp,
		"error caused by"), nil
}

// HandleRuntimeError handles runtime errors and separates
// errors generated by runtime from fvm errors (e.g. environment errors)
func HandleRuntimeError(inp error) (err error) {
	if inp == nil {
		return nil
	}

	// if is not a runtime error return as vm error
	// this should never happen unless a bug in the code
	runErr, ok := inp.(runtime.Error)
	if !ok {
		return NewUnknownFailure(err)
	}

	// wrap all runtime errors as CadenceRuntimeError
	defer func() {
		err = WrapCodedError(
			ErrCodeCadenceRunTimeError,
			err,
			"cadence runtime error",
		)
	}()

	// cadence ParentError types contain a list of errors encountered during execution
	// this special case can be removed once these errors are updated to conform to the
	// unwrappable interface used by the std errors lib. See
	var parentErr errors.ParentError
	if As(inp, &parentErr) {
		err = WrappedParentError{parentErr}
	}

	// Error lists need to be handled carefully because the std errors lib and the logic in this file
	// behave subtly different wrt which errors are returned. specifically:
	// - std errors methods will recursively unwrap single errors and error lists until they finds
	//   the first match using a depth-first search.
	// - findRootCodedError will also recursively unwrap single errors and error lists, but it
	//   will continue to search until it finds the deepest coded error in the first branch containing
	//   any coded error. This means it will fail to find CodedFailures if there are any CodedErrors
	//   earlier in the unwrapped error list.
	var wrapped UnwrappableErrors
	if As(err, &wrapped) {
		// first search through all of the errors for a coded failure. this ensures that a failure
		// is returned if there were any failures anywhere in the error tree.
		// Note: failure usually means unexpected fatal exceptions, and best to be treated
		// as high priority to look into before any other errors. That's why as soon as we can
		// find them, they should be returned.
		var failure CodedFailure
		if As(wrapped, &failure) {
			err = WrapCodedFailure(
				failure.Code(),
				inp,
				"cadence runtime failure caused by",
			)
			return
		}

		// next, do a depth-first search for the first coded error. this ensures that the deepest
		// coded error in the chain is returned.
		// Note, the coded error are for known non-fatal error cases, if we can find any of them, we
		// will highlight its code
		var coded CodedError
		if As(wrapped, &coded) {
			// find the deepest coded error
			coded, _ = findRootCodedError(coded)
			// we've already check that the error is a CodedError, so ignoring the return value
			err = WrapCodedError(
				coded.Code(),
				inp,
				"cadence runtime error caused by",
			)
			return
		}
	}

	// All other errors are non-fatal Cadence errors.
	err = runErr
	return
}

// HasErrorCode returns true if the error or one of its nested errors matches the
// specified error code.
func HasErrorCode(err error, code ErrorCode) bool {
	return Find(err, code) != nil
}

// HasFailureCode returns true if the error or one of its nested errors matches the
// specified failure code.
func HasFailureCode(err error, code FailureCode) bool {
	return FindFailure(err, code) != nil
}

// Find recursively unwraps the error and returns first CodedError that matches
// the specified error code.
func Find(originalErr error, code ErrorCode) CodedError {
	if originalErr == nil {
		return nil
	}

	var unwrappable Unwrappable
	if !As(originalErr, &unwrappable) {
		return nil
	}

	coded, ok := unwrappable.(CodedError)
	if ok && coded.Code() == code {
		return coded
	}

	return Find(unwrappable.Unwrap(), code)
}

// FindFailure recursively unwraps the error and returns first CodedFailure that matches
// the specified error code.
func FindFailure(originalErr error, code FailureCode) CodedFailure {
	if originalErr == nil {
		return nil
	}

	var unwrappable Unwrappable
	if !As(originalErr, &unwrappable) {
		return nil
	}

	coded, ok := unwrappable.(CodedFailure)
	if ok && coded.Code() == code {
		return coded
	}

	return FindFailure(unwrappable.Unwrap(), code)
}

var _ CodedError = (*codedError)(nil)

type codedError struct {
	code ErrorCode

	err error
}

func newError(
	code ErrorCode,
	rootCause error,
) codedError {
	return codedError{
		code: code,
		err:  rootCause,
	}
}

func WrapCodedError(
	code ErrorCode,
	err error,
	prefixMsgFormat string,
	formatArguments ...interface{},
) codedError {
	if prefixMsgFormat != "" {
		msg := fmt.Sprintf(prefixMsgFormat, formatArguments...)
		err = fmt.Errorf("%s: %w", msg, err)
	}
	return newError(code, err)
}

func NewCodedError(
	code ErrorCode,
	format string,
	formatArguments ...interface{},
) codedError {
	return newError(code, fmt.Errorf(format, formatArguments...))
}

func (err codedError) Unwrap() error {
	return err.err
}

func (err codedError) Error() string {
	return fmt.Sprintf("%v %v", err.code, err.err)
}

func (err codedError) Code() ErrorCode {
	return err.code
}

var _ CodedFailure = (*codedFailure)(nil)

type codedFailure struct {
	code FailureCode
	err  error
}

func newFailure(
	code FailureCode,
	rootCause error,
) codedFailure {
	return codedFailure{
		code: code,
		err:  rootCause,
	}
}

func WrapCodedFailure(
	code FailureCode,
	err error,
	prefixMsgFormat string,
	formatArguments ...interface{},
) codedFailure {
	if prefixMsgFormat != "" {
		msg := fmt.Sprintf(prefixMsgFormat, formatArguments...)
		err = fmt.Errorf("%s: %w", msg, err)
	}
	return newFailure(code, err)
}

func NewCodedFailure(
	code FailureCode,
	format string,
	formatArguments ...interface{},
) codedFailure {
	return newFailure(code, fmt.Errorf(format, formatArguments...))
}

func (err codedFailure) Unwrap() error {
	return err.err
}

func (err codedFailure) Error() string {
	return fmt.Sprintf("%v %v", err.code, err.err)
}

func (err codedFailure) Code() FailureCode {
	return err.code
}

// NewEventEncodingError construct a new CodedError which indicates
// that encoding event has failed
func NewEventEncodingError(err error) CodedError {
	return NewCodedError(
		ErrCodeEventEncodingError,
		"error while encoding emitted event: %w ", err)
}

// EVMError needs to satisfy the user error interface
// in order for Cadence to correctly handle the error
var _ errors.UserError = &(EVMError{})

type EVMError struct {
	CodedError
}

func (e EVMError) IsUserError() {}

// NewEVMError constructs a new CodedError which captures a
// collection of errors provided by (non-fatal) evm runtime.
func NewEVMError(err error) EVMError {
	return EVMError{
		WrapCodedError(
			ErrEVMExecutionError,
			err,
			"evm runtime error"),
	}
}

// IsEVMError returns true if error is an EVM error
func IsEVMError(err error) bool {
	return HasErrorCode(err, ErrEVMExecutionError)
}
