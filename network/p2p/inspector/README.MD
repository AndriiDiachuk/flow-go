# Control Message Validation Inspector Overview

## Component Overview
The Control Message Validation Inspector (`ControlMsgValidationInspector`) is an injectable component responsible for asynchronous inspection of incoming GossipSub RPC.
It is entirely developed and maintained at Flow blockchain codebase and is injected into the GossipSub protocol of libp2p at the startup of the node.
All incoming RPC messages are passed through this inspection to ensure their validity and compliance with the Flow protocol semantics.

The inspector performs two primary functions:
1. **RPC truncation (blocking)**: It truncates size of incoming RPC messages to prevent excessive resource consumption, if needed. This is done by sampling the messages and reducing their size to a configurable threshold.
2. **RPC inspection (non-blocking)**: It inspects the truncated or original RPC messages for compliance with the Flow protocol semantics. This includes validation of message structure, topic, sender, and other relevant attributes.

## What is an RPC?
RPC stands for Remote Procedure Call. In the context of GossipSub, it is a message that is sent from one peer to another peer over the GossipSub protocol. 
The message is sent in the form of a protobuf message and is used to communicate information about the state of the network, such as topic membership, message propagation, and other relevant information.
It encapsulates various types of messages and commands that peers exchange to implement the GossipSub protocol, a pub-sub (publish-subscribe) messaging system. 
Remember that the purpose of GossipSub is to efficiently disseminate messages to interested subscribers in the network without requiring a central broker or server.
Here is what an RPC message looks like in the context of GossipSub:
```go
type RPC struct {
	Subscriptions        []*RPC_SubOpts  `protobuf:"bytes,1,rep,name=subscriptions" json:"subscriptions,omitempty"`
	Publish              []*Message      `protobuf:"bytes,2,rep,name=publish" json:"publish,omitempty"`
	Control              *ControlMessage `protobuf:"bytes,3,opt,name=control" json:"control,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}
``` 

Here's a breakdown of the components within the GossipSub's `RPC` struct:
1. **Subscriptions (`[]*RPC_SubOpts`)**: This field contains a list of subscription options (`RPC_SubOpts`). 
    Each `RPC_SubOpts` represents a peer's intent to subscribe or unsubscribe from a topic. 
    This allows peers to dynamically adjust their interest in various topics and manage their subscription list.
2. **Publish (`[]*Message`)**: The `Publish` field contains a list of messages that the peer wishes to publish (or gossip) to the network. 
    Each `Message` is intended for a specific topic, and peers subscribing to that topic should receive the message. 
    This field is essential for the dissemination of information and data across the network.
3. **Control (`*ControlMessage`)**
    The `Control` field holds a control message, which contains various types of control information required for the operation of the GossipSub protocol. 
    This can include information about grafting (joining a mesh for a topic), pruning (leaving a mesh), 
    and other control signals related to the maintenance and optimization of the pub-sub network. 
   The control messages play a crucial role in the mesh overlay maintenance, ensuring efficient and reliable message propagation.
4. **XXX Fields** These fields (`XXX_NoUnkeyedLiteral`, `XXX_unrecognized`, and `XXX_sizecache`) are generated by the protobuf compiler and are not directly used by the GossipSub protocol. 
   They are used internally by the protobuf library for various purposes like caching and ensuring correct marshalling and unmarshalling of the protobuf data.

### Closer Look at the Control Message
In GossipSub, a Control Message is a part of the `RPC` structure and plays a crucial role in maintaining and optimizing the network. 
It contains several fields, each corresponding to different types of control information.
The primary purpose of these control messages is to manage the mesh overlay that underpins the GossipSub protocol,
ensuring efficient and reliable message propagation.

At the core, the control messages are used to maintain the mesh overlay for each topic, allowing peers to join and leave the mesh as their interests and network connectivity change.
The control messages include the following types:

1. **IHAVE (`[]*ControlIHave`)**: the `IHAVE` messages are used to advertise to peers that the sender has certain messages. 
   This is part of the message propagation mechanism. 
   When a peer receives an `IHAVE` message and is interested in the advertised messages (because it doesn't have them yet), 
   it can request those messages from the sender using an `IWANT` message.

2. **IWANT (`[]*ControlIWant`)**: the `IWANT` messages are requests sent to peers to ask for specific messages previously 
   advertised in an `IHAVE` message. 
   This mechanism ensures that messages propagate through the network, 
   reaching interested subscribers even if they are not directly connected to the message's original publisher.

3. **GRAFT (`[]*ControlGraft`)**: The `GRAFT` messages are used to express the sender's intention to join the mesh for a specific topic. 
   In GossipSub, each peer maintains a local mesh network for each topic it is interested in. 
   Each local mesh is a subset of the peers in the network that are interested in the same topic. The complete mesh for a topic is formed by the union of all local meshes, which must be connected to ensure efficient message propagation 
   (the peer scoring ensures that the mesh is well-connected and that peers are not overloaded with messages)
   Sending a `GRAFT` message is a way to join the local mesh of a peer, indicating that the sender wants to receive and forward messages for the specific topic.

4. **PRUNE (`[]*ControlPrune`)**: conversely, `PRUNE` messages are sent when a peer wants to leave the local mesh for a specific topic. 
   This could be because the peer is no longer interested in the topic or is optimizing its network connections. 
   Upon receiving a `PRUNE` message, peers will remove the sender from their mesh for the specific topic.

```go
type ControlMessage struct {
	Ihave                []*ControlIHave `protobuf:"bytes,1,rep,name=ihave" json:"ihave,omitempty"`
	Iwant                []*ControlIWant `protobuf:"bytes,2,rep,name=iwant" json:"iwant,omitempty"`
	Graft                []*ControlGraft `protobuf:"bytes,3,rep,name=graft" json:"graft,omitempty"`
	Prune                []*ControlPrune `protobuf:"bytes,4,rep,name=prune" json:"prune,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}
```
