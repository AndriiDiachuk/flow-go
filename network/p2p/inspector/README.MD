# Control Message Validation Inspector Overview

## Component Overview
The Control Message Validation Inspector (`ControlMsgValidationInspector`) is an injectable component responsible for asynchronous inspection of incoming GossipSub RPC.
It is entirely developed and maintained at Flow blockchain codebase and is injected into the GossipSub protocol of libp2p at the startup of the node.
All incoming RPC messages are passed through this inspection to ensure their validity and compliance with the Flow protocol semantics.

The inspector performs two primary functions:
1. **RPC truncation (blocking)**: It truncates size of incoming RPC messages to prevent excessive resource consumption, if needed. This is done by sampling the messages and reducing their size to a configurable threshold.
2. **RPC inspection (non-blocking)**: It inspects the truncated or original RPC messages for compliance with the Flow protocol semantics. This includes validation of message structure, topic, sender, and other relevant attributes.

## What is an RPC?
RPC stands for Remote Procedure Call. In the context of GossipSub, it is a message that is sent from one peer to another peer over the GossipSub protocol. 
The message is sent in the form of a protobuf message and is used to communicate information about the state of the network, such as topic membership, message propagation, and other relevant information.
It encapsulates various types of messages and commands that peers exchange to implement the GossipSub protocol, a pub-sub (publish-subscribe) messaging system. 
Remember that the purpose of GossipSub is to efficiently disseminate messages to interested subscribers in the network without requiring a central broker or server.
Here is what an RPC message looks like in the context of GossipSub:
```protobuf
type RPC struct {
	Subscriptions        []*RPC_SubOpts  `protobuf:"bytes,1,rep,name=subscriptions" json:"subscriptions,omitempty"`
	Publish              []*Message      `protobuf:"bytes,2,rep,name=publish" json:"publish,omitempty"`
	Control              *ControlMessage `protobuf:"bytes,3,opt,name=control" json:"control,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}
``` 

Here's a breakdown of the components within the GossipSub's `RPC` struct:
1. **Subscriptions (`[]*RPC_SubOpts`)**: This field contains a list of subscription options (`RPC_SubOpts`). 
    Each `RPC_SubOpts` represents a peer's intent to subscribe or unsubscribe from a topic. 
    This allows peers to dynamically adjust their interest in various topics and manage their subscription list.
2. **Publish (`[]*Message`)**: The `Publish` field contains a list of messages that the peer wishes to publish (or gossip) to the network. 
    Each `Message` is intended for a specific topic, and peers subscribing to that topic should receive the message. 
    This field is essential for the dissemination of information and data across the network.
3. **Control (`*ControlMessage`)**
    The `Control` field holds a control message, which contains various types of control information required for the operation of the GossipSub protocol. 
    This can include information about grafting (joining a mesh for a topic), pruning (leaving a mesh), 
    and other control signals related to the maintenance and optimization of the pub-sub network. 
   The control messages play a crucial role in the mesh overlay maintenance, ensuring efficient and reliable message propagation.
4. **XXX Fields** These fields (`XXX_NoUnkeyedLiteral`, `XXX_unrecognized`, and `XXX_sizecache`) are generated by the protobuf compiler and are not directly used by the GossipSub protocol. 
   They are used internally by the protobuf library for various purposes like caching and ensuring correct marshalling and unmarshalling of the protobuf data.


